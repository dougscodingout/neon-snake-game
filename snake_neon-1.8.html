<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="utf-8" />
<title>Neon Snake v1.7 ‚Äî LEVA 1 (Visual + HUD)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#000;font-family:system-ui,Segoe UI,Roboto,Ubuntu,sans-serif;color:#e8ffff;overflow:hidden;}
  .wrap{display:grid;place-items:center;height:100%;}
  .hud{display:flex;gap:12px;margin-bottom:12px;justify-content:center;align-items:center;flex-wrap:wrap}
  .badge{background:rgba(0,0,0,.4);border:1px solid #0ff6;border-radius:12px;padding:8px 14px;color:#cff;box-shadow:0 0 12px #0ff4,inset 0 0 6px #00fffa33;text-shadow:0 0 8px #0ff8;transition:all .3s ease;}
  .world{border-color:#ff7bf5}
  .tests{border-color:#7fff7f}
  
  /* NOVO: Golden Mode Timer */
  .golden-timer{border-color:#ffd700;background:rgba(255,215,0,.15);display:none;}
  .golden-timer.active{display:inline-block;animation:goldenPulse 0.5s ease-in-out infinite alternate;}
  @keyframes goldenPulse{to{box-shadow:0 0 20px #ffd700,inset 0 0 10px #ffd70066;}}
  
  /* NOVO: Combo Display */
  .combo-display{border-color:#ff6b00;background:rgba(255,107,0,.2);display:none;font-weight:bold;}
  .combo-display.active{display:inline-block;animation:comboBounce 0.3s ease-out;}
  @keyframes comboBounce{0%,100%{transform:scale(1)}50%{transform:scale(1.15)}}
  
  /* NOVO: Power-up Counter */
  .powerup-count{border-color:#ffff00;background:rgba(255,255,0,.1);}
  
  canvas{background:radial-gradient(circle at 40% 40%,#050015,#000);border-radius:22px;box-shadow:0 0 30px #0ff6,inset 0 0 40px #00ffee22;transition:all .3s ease;}
  
  /* NOVO: Canvas Golden State */
  canvas.golden-active{
    animation:goldenZoom 1s ease-in-out infinite alternate;
    filter:blur(1px) saturate(1.6) brightness(1.2);
  }
  @keyframes goldenZoom{to{transform:scale(1.05)}}
  
  /* NOVO: Flash Overlay */
  .flash-overlay{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999;opacity:0;transition:opacity .2s;}
  .flash-overlay.white{background:#fff;opacity:1;}
  .flash-overlay.violet{background:radial-gradient(circle,#ff00ff,#4400ff);opacity:0.4;}
  .flash-overlay.gold{background:radial-gradient(circle,#ffd700,#ff8c00);opacity:0.3;}
  
  .note{margin-top:8px;text-align:center;font-size:14px;opacity:.85;color:#f8f}
</style>
</head>
<body>
  <!-- NOVO: Flash Overlay -->
  <div class="flash-overlay" id="flashOverlay"></div>
  
  <div class="wrap">
    <div>
      <div class="hud">
        <div class="badge">Score: <span id="score">0</span></div>
        <div class="badge">Best: <span id="best">0</span></div>
        <div class="badge world">World: <span id="worldLabel">1 ‚Ä¢ Cyberpunk Dusk</span></div>
        
        <!-- NOVO: Golden Timer -->
        <div class="badge golden-timer" id="goldenTimer">‚ö° Golden: <span id="goldenTime">0</span>s</div>
        
        <!-- NOVO: Combo Display -->
        <div class="badge combo-display" id="comboDisplay">üî• COMBO x<span id="comboValue">1</span></div>
        
        <!-- NOVO: Power-up Counter -->
        <div class="badge powerup-count">üíé Crystals: <span id="powerupCount">0</span></div>
        
        <div class="badge" id="msg">Pressione <b>Espa√ßo</b> para iniciar</div>
        <div class="badge tests" id="testBadge" style="display:none">Tests: running‚Ä¶</div>
      </div>
      <canvas id="cv" width="720" height="720"></canvas>
      <div class="note">üé® LEVA 1: Slow Motion Visual + HUD Aprimorada ‚Ä¢ Golden Halo ‚Ä¢ Combo System ‚Ä¢ Power-up Counter</div>
    </div>
  </div>

<script>
(()=>{
  // ===========================
  // CONFIG B√ÅSICA
  // ===========================
  const CELL=24, COLS=30, ROWS=30;
  const cv=document.getElementById('cv');
  const ctx=cv.getContext('2d');
  const scoreEl=document.getElementById('score');
  const bestEl=document.getElementById('best');
  const msgEl=document.getElementById('msg');
  const worldEl=document.getElementById('worldLabel');
  const testBadge=document.getElementById('testBadge');
  
  // NOVO: Elementos HUD
  const goldenTimerEl=document.getElementById('goldenTimer');
  const goldenTimeEl=document.getElementById('goldenTime');
  const comboDisplayEl=document.getElementById('comboDisplay');
  const comboValueEl=document.getElementById('comboValue');
  const powerupCountEl=document.getElementById('powerupCount');
  const flashOverlay=document.getElementById('flashOverlay');

  // ===========================
  // ESTADO DE JOGO
  // ===========================
  let snake=[], dir={x:1,y:0}, nextDir={x:1,y:0};
  let apple=null, score=0, best=+localStorage.neonSnakeBest||0;
  let tick=100;
  let logicTimer=null;
  let restarting=false;

  // Combo
  let combo=0, lastEat=0;

  // Power-ups
  let powerUps=[];

  // Golden Mode 2.0
  const GOLDEN_MS=5000;
  let invincible=false, invEnd=0, slowMotion=false;

  // Part√≠culas
  const particles=[];
  const MAX_PARTICLES=100;

  // Mundo / Progress√£o audiovisual
  const WORLDS=[
    { name:'Cyberpunk Dusk',   bg:'#0a0022', color:'#0ff', bpm:90,  bass:55,  palette:['#0ff','#f0f','#ff0'],  chime:false, sweep:false },
    { name:'Synthwave Sunset', bg:'#220a0a', color:'#ff1493', bpm:100, bass:65, palette:['#ff1493','#ff8800','#ffff00'], chime:false, sweep:false },
    { name:'Neon Forest',      bg:'#0a2200', color:'#0f0', bpm:110, bass:73, palette:['#0f0','#0ff','#88ffaa'], chime:false, sweep:false },
    { name:'Electric Storm',   bg:'#000a22', color:'#0af', bpm:120, bass:82, palette:['#0af','#80f','#fff'],    chime:true,  sweep:false },
    { name:'Rainbow Chaos',    bg:'#2a0a2a', color:'#0ff', bpm:130, bass:92, palette:['rainbow','#fff','#0ff'], chime:true,  sweep:true  }
  ];
  let worldIndex=0;

  // Transi√ß√£o de mundos
  let transitioning=false;
  let transitionText='';
  let transitionStart=0;
  const TRANSITION_MS=2000;

  // Grid/Glow/Shake reativos
  let lastBeatNow=performance.now();
  let shake=0, shakeT=0, shakeRot=0;
  
  // NOVO: Halo dourado (Golden Mode)
  let haloIntensity=0; // 0 a 1

  // ===========================
  // √ÅUDIO (Web Audio API)
  // ===========================
  let audioCtx=null, baseGain=null;
  let delayNode=null, feedbackGain=null, filterNode=null;
  let bassOsc=null, bassGain=null, lfo=null, lfoGain=null;
  let padGains=[], padOscs=[];
  let arpInterval=null;
  let chimeInterval=null;
  let sweepInterval=null;
  let loopRunning=false, tempo=90;

  function setupAudio(){
    if(loopRunning) return;
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();

    baseGain = audioCtx.createGain();
    baseGain.gain.value = 0.10;

    delayNode = audioCtx.createDelay(); delayNode.delayTime.value=0.25;
    feedbackGain = audioCtx.createGain(); feedbackGain.gain.value=0.25;
    filterNode = audioCtx.createBiquadFilter(); filterNode.type='lowpass'; filterNode.frequency.value=6000;

    baseGain.connect(audioCtx.destination);
    baseGain.connect(delayNode);
    delayNode.connect(feedbackGain); feedbackGain.connect(delayNode);
    delayNode.connect(filterNode); filterNode.connect(audioCtx.destination);

    bassOsc = audioCtx.createOscillator(); bassOsc.type='sawtooth';
    bassGain = audioCtx.createGain(); bassGain.gain.value=0.10;
    bassOsc.connect(bassGain).connect(baseGain);
    lfo = audioCtx.createOscillator(); lfoGain = audioCtx.createGain(); lfo.frequency.value=2; lfoGain.gain.value=25;
    lfo.connect(lfoGain).connect(bassOsc.frequency);

    bassOsc.start(); lfo.start();
    loopRunning=true;

    applyWorld(true);
    scheduleBeat();
    startArpIfNeeded();
    startChimesIfNeeded();
    startSweepIfNeeded();
  }

  function beep(freq,durMs,type='sine',vol=0.12){
    if(!audioCtx) return;
    const osc=audioCtx.createOscillator(); const g=audioCtx.createGain();
    osc.type=type; osc.frequency.value=freq; g.gain.value=vol;
    osc.connect(g).connect(baseGain);
    const now=audioCtx.currentTime; osc.start();
    g.gain.exponentialRampToValueAtTime(0.0001, now + durMs/1000);
    osc.stop(now + durMs/1000);
  }

  function scheduleBeat(){
    if(!loopRunning) return;
    const beat = 60/tempo;
    const nowT = audioCtx.currentTime;

    const kick = audioCtx.createOscillator(); kick.type='sine';
    const kg = audioCtx.createGain();
    kick.frequency.setValueAtTime(150, nowT);
    kick.frequency.exponentialRampToValueAtTime(40, nowT+0.2);
    kg.gain.setValueAtTime(0.4, nowT);
    kg.gain.exponentialRampToValueAtTime(0.001, nowT+0.30);
    kick.connect(kg).connect(baseGain);
    kick.start(); kick.stop(nowT+0.30);

    lastBeatNow = performance.now();

    if(invincible){
      triggerShake(8, 500, 0.02);
    } else {
      triggerShake(2, 100, 0);
    }

    setTimeout(scheduleBeat, beat*1000);
  }

  function applyWorld(first=false){
    const W = WORLDS[worldIndex];
    document.body.style.background = `radial-gradient(circle at 50% 20%, ${W.bg}, #000)`;
    cv.style.boxShadow = `0 0 40px ${W.color}99, inset 0 0 50px ${W.color}33`;

    if(audioCtx && bassOsc){
      bassOsc.frequency.linearRampToValueAtTime(W.bass, audioCtx.currentTime+1.0);
      tempo = W.bpm;
    }

    stopPads();
    if(worldIndex>=1) startPads(W);

    stopArp();
    if(worldIndex>=2) startArpIfNeeded();

    stopChimes();
    if(W.chime) startChimesIfNeeded();

    stopSweep();
    if(W.sweep) startSweepIfNeeded();

    worldEl.textContent = `${worldIndex+1} ‚Ä¢ ${W.name}`;

    if(!first){
      cv.animate([{filter:'brightness(2) saturate(1.6)'},{filter:'brightness(1) saturate(1)'}],{duration:600});
    }
  }

  function startPads(W){
    padOscs=[]; padGains=[];
    const freqs = [W.bass*2, W.bass*3, W.bass*4];
    freqs.forEach((f,i)=>{
      const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.value=f;
      const g=audioCtx.createGain(); g.gain.value=0.0;
      o.connect(g).connect(baseGain); o.start();
      g.gain.linearRampToValueAtTime(0.03, audioCtx.currentTime+1);
      padOscs.push(o); padGains.push(g);
    });
  }
  function stopPads(){ padOscs.forEach(o=>{try{o.stop()}catch{}}); padOscs=[]; padGains=[]; }

  function startArpIfNeeded(){
    if(arpInterval) return;
    if(!audioCtx) return;
    arpInterval = setInterval(()=>{
      const W=WORLDS[worldIndex]; if(worldIndex<2) return;
      const seq=[1,1.25,1.5,2];
      const ratio = seq[Math.floor(Math.random()*seq.length)];
      const o=audioCtx.createOscillator(); o.type='triangle'; o.frequency.value=W.bass*ratio*2;
      const g=audioCtx.createGain(); g.gain.value=0.05;
      o.connect(g).connect(baseGain);
      const t=audioCtx.currentTime; o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.3); o.stop(t+0.3);
    }, (60/Math.max(tempo,1))*500);
  }
  function stopArp(){ if(arpInterval){ clearInterval(arpInterval); arpInterval=null; } }

  function startChimesIfNeeded(){
    if(chimeInterval) return;
    chimeInterval = setInterval(()=>{
      if(!audioCtx || !WORLDS[worldIndex].chime) return;
      const notes=[261.63,293.66,329.63,392.00,440.00];
      const n=notes[Math.floor(Math.random()*notes.length)];
      const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.value=n;
      const g=audioCtx.createGain(); g.gain.value=0.08;
      o.connect(g).connect(baseGain);
      const t=audioCtx.currentTime; o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, t+1.5); o.stop(t+1.5);
    }, (60/Math.max(tempo,1))*2000);
  }
  function stopChimes(){ if(chimeInterval){ clearInterval(chimeInterval); chimeInterval=null; } }

  function startSweepIfNeeded(){
    if(sweepInterval) return;
    sweepInterval = setInterval(()=>{
      if(!audioCtx || !WORLDS[worldIndex].sweep) return;
      const noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate*0.2, audioCtx.sampleRate);
      const data=noiseBuf.getChannelData(0);
      for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1;
      const src=audioCtx.createBufferSource(); src.buffer=noiseBuf;
      const bp=audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=200;
      const g=audioCtx.createGain(); g.gain.value=0.06;
      src.connect(bp).connect(g).connect(baseGain);
      const t=audioCtx.currentTime; src.start(); src.stop(t+0.4);
      bp.frequency.linearRampToValueAtTime(2000, t+0.4);
    }, (60/Math.max(tempo,1))*4000);
  }
  function stopSweep(){ if(sweepInterval){ clearInterval(sweepInterval); sweepInterval=null; } }

  // GOLDEN FX
  function enterGolden(){
    invincible=true; slowMotion=true; invEnd = Date.now() + GOLDEN_MS;
    
    // NOVO: Flash branco + explos√£o violeta
    triggerFlash('white', 200);
    setTimeout(()=>triggerFlash('violet', 600), 200);
    
    // NOVO: Ativar classe CSS no canvas
    cv.classList.add('golden-active');
    
    // NOVO: Mostrar timer
    goldenTimerEl.classList.add('active');
    
    if(audioCtx){
      baseGain.gain.linearRampToValueAtTime(0.07, audioCtx.currentTime+0.4);
      filterNode.frequency.linearRampToValueAtTime(1500, audioCtx.currentTime+0.4);
      feedbackGain.gain.linearRampToValueAtTime(0.6, audioCtx.currentTime+0.4);
    }
  }
  
  function exitGolden(){
    invincible=false; slowMotion=false;
    
    // NOVO: Flash dourado de sa√≠da
    triggerFlash('gold', 400);
    
    // NOVO: Remover classe CSS
    cv.classList.remove('golden-active');
    
    // NOVO: Esconder timer
    goldenTimerEl.classList.remove('active');
    
    if(audioCtx){
      baseGain.gain.linearRampToValueAtTime(0.10, audioCtx.currentTime+0.4);
      filterNode.frequency.linearRampToValueAtTime(6000, audioCtx.currentTime+0.4);
      feedbackGain.gain.linearRampToValueAtTime(0.25, audioCtx.currentTime+0.4);
    }
  }
  
  // NOVO: Sistema de Flash
  function triggerFlash(type, durationMs){
    flashOverlay.className = `flash-overlay ${type}`;
    setTimeout(()=>{
      flashOverlay.className = 'flash-overlay';
    }, durationMs);
  }

  // ===========================
  // UTIL
  // ===========================
  const rnd=n=>Math.floor(Math.random()*n);
  const same=(a,b)=>a&&b&&a.x===b.x&&a.y===b.y;
  const isInt=n=>Number.isInteger(n);
  const isFiniteNum=n=>Number.isFinite(n);
  const validCell=(x,y)=>isInt(x)&&isInt(y)&&x>=0&&x<COLS&&y>=0&&y<ROWS;

  // ===========================
  // INICIALIZA / REINICIA JOGO
  // ===========================
  function startGame(){
    clearInterval(logicTimer);
    const cx=Math.floor(COLS/2), cy=Math.floor(ROWS/2);
    snake=[{x:cx,y:cy},{x:cx-1,y:cy},{x:cx-2,y:cy}];
    dir=nextDir={x:1,y:0};
    score=0; combo=0; particles.length=0;
    powerUps=[]; generatePowerUps();
    placeApple();
    transitioning=false; transitionText='';
    msgEl.textContent='Jogando‚Ä¶';
    scoreEl.textContent=score; bestEl.textContent=best;
    
    // NOVO: Reset HUD
    updatePowerupCounter();
    comboDisplayEl.classList.remove('active');
    
    logicTimer=setInterval(stepLogic, tick);
  }

  function placeApple(){
    let tries=0;
    do{ apple={x:rnd(COLS), y:rnd(ROWS)}; tries++; if(tries>100) break; }
    while(snake.some(p=>same(p,apple)) || powerUps.some(p=>same(p,apple)));
    if(!validCell(apple.x, apple.y)) apple={x:0,y:0};
  }

  function powerupCountForLevel(){
    const sc = score;
    if(sc<20) return 5;
    if(sc<40) return 4;
    if(sc<80) return 3;
    if(sc<200) return 2;
    return 1;
  }

  function generatePowerUps(){
    powerUps=[];
    const count = powerupCountForLevel();
    for(let i=0;i<count;i++){
      let p; let guard=0;
      do{ p={x:rnd(COLS), y:rnd(ROWS)}; guard++; if(guard>200) break; }
      while(snake.some(s=>same(s,p)) || (apple && same(p,apple)));
      if(validCell(p.x,p.y)) powerUps.push(p);
    }
    updatePowerupCounter();
  }
  
  // NOVO: Atualizar contador de power-ups
  function updatePowerupCounter(){
    powerupCountEl.textContent = powerUps.length;
  }
  
  // NOVO: Atualizar display de combo
  function updateCombo(){
    if(combo > 1){
      comboDisplayEl.classList.add('active');
      comboValueEl.textContent = combo;
    } else {
      comboDisplayEl.classList.remove('active');
    }
  }

  // ===========================
  // L√ìGICA DO JOGO (INTERVAL)
  // ===========================
  function stepLogic(){
    if(transitioning) return;

    if(nextDir) dir = nextDir;

    let head={x:snake[0].x+dir.x, y:snake[0].y+dir.y};

    if(invincible){
      if(head.x<0) head.x=COLS-1; if(head.x>=COLS) head.x=0;
      if(head.y<0) head.y=ROWS-1; if(head.y>=ROWS) head.y=0;
    } else {
      if(head.x<0||head.x>=COLS||head.y<0||head.y>=ROWS){ crash(); return; }
    }

    if(!invincible && snake.some(p=>same(p,head))){ crash(); return; }

    snake.unshift(head);

    if(apple && same(head,apple)){
      const now=Date.now();
      combo = (now-lastEat<3000) ? combo+1 : 1; lastEat=now;
      const mult = 1 + (combo-1)*0.5;
      score += Math.round(1*mult);
      scoreEl.textContent=score;
      beep(600+combo*50, 120, 'square', 0.20);
      spawnParticles(head.x, head.y, 10, getPrimaryColor());
      
      // NOVO: Atualizar combo display
      updateCombo();

      maybeWorldTransition();
      placeApple();
    }
    else if(powerUps.some(p=>same(p,head))){
      powerUps = powerUps.filter(p=>!same(p,head));
      updatePowerupCounter();
      enterGolden();
      beep(1000, 200, 'triangle', 0.30);
    }
    else {
      snake.pop();
    }

    if(invincible && Date.now()>invEnd){ exitGolden(); }
  }

  function crash(){
    if(invincible || restarting) return;
    restarting=true; cv.style.filter='brightness(2)';
    beep(120, 400, 'sawtooth', 0.25);
    best=Math.max(best,score); bestEl.textContent=best; localStorage.neonSnakeBest=best;
    clearInterval(logicTimer);
    
    // NOVO: Reset combo
    combo=0; updateCombo();
    
    setTimeout(()=>{ cv.style.filter='brightness(1)'; restarting=false; startGame(); }, 800);
  }

  function maybeWorldTransition(){
    const prevWorld = worldIndex;
    const s=score;
    if(s>=80) worldIndex=4; else if(s>=60) worldIndex=3; else if(s>=40) worldIndex=2; else if(s>=20) worldIndex=1; else worldIndex=0;
    if(worldIndex!==prevWorld){
      transitioning=true; transitionStart=performance.now();
      transitionText = `ENTERING ${WORLDS[worldIndex].name.toUpperCase()}`;
      applyWorld(); generatePowerUps();
      setTimeout(()=>{ transitioning=false; }, TRANSITION_MS);
    }
  }

  // ===========================
  // RENDER (RAF 60FPS)
  // ===========================
  function animate(){
    requestAnimationFrame(animate);
    try{ draw(); }catch(err){ console.error('[draw] error', err); }
  }

  function triggerShake(px, durationMs, rot){
    shake = Math.max(shake, px);
    shakeT = performance.now() + durationMs;
    shakeRot = rot||0;
  }

  function draw(){
    const W = WORLDS[worldIndex];

    // NOVO: Atualizar Golden Timer
    if(invincible){
      const tLeft = Math.max(0, invEnd - Date.now());
      goldenTimeEl.textContent = (tLeft/1000).toFixed(1);
      
      // Aumentar halo intensity
      haloIntensity = Math.min(1, haloIntensity + 0.05);
    } else {
      haloIntensity = Math.max(0, haloIntensity - 0.05);
    }

    const now=performance.now();
    const activeShake = Math.max(0, shakeT - now);
    let offX=0, offY=0, rot=0;
    if(activeShake>0){
      const k = activeShake/500;
      offX = (Math.random()*2-1) * shake * k;
      offY = (Math.random()*2-1) * shake * k;
      rot = (Math.random()*2-1) * (shakeRot||0) * k;
    }

    const sinceBeat = now - lastBeatNow;
    const beatPhase = Math.max(0, 1 - sinceBeat/200);
    const gridAlpha = 0.06 + beatPhase * 0.14;

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,cv.width,cv.height);

    ctx.translate(offX, offY);
    if(rot) ctx.rotate(rot);

    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,cv.width,cv.height);

    // Grade
    ctx.strokeStyle = hexToRgba(W.color, (invincible? (gridAlpha*1.6) : gridAlpha));
    ctx.beginPath();
    for(let i=1;i<COLS;i++){
      const x=i*CELL + (invincible? Math.sin(now/100 + i)*3 : 0);
      ctx.moveTo(x+.5, 0); ctx.lineTo(x+.5, cv.height);
    }
    for(let j=1;j<ROWS;j++){
      const y=j*CELL + (invincible? Math.sin(now/120 + j)*3 : 0);
      ctx.moveTo(0, y+.5); ctx.lineTo(cv.width, y+.5);
    }
    ctx.stroke();

    // Ma√ß√£
    if(apple && validCell(apple.x, apple.y)) safeDrawOrb(apple.x, apple.y, W.color);

    // Power-ups dourados
    for(const p of powerUps){ if(validCell(p.x,p.y)) safeDrawOrb(p.x,p.y,'#ff0'); }

    // Part√≠culas
    updateParticles();

    // Cobra
    snake.forEach((p,i)=>{
      const hueBase = (W.palette[0]==='rainbow') ? ((now/100 + i*6)%360) : null;
      const fill = invincible
        ? 'hsl(50,100%,65%)'
        : (hueBase!=null ? `hsl(${hueBase},100%,60%)` : W.palette[0]);
      ctx.fillStyle = fill;
      ctx.shadowColor = invincible? '#ffd700' : W.color;
      ctx.shadowBlur = invincible? 20 : 8;
      drawCell(p.x, p.y, 5);
      ctx.shadowBlur=0;
    });

    // GLOW geral
    const glow = 30 + (beatPhase*18) + score/8;
    cv.style.boxShadow = `0 0 ${glow}px ${W.color}AA, inset 0 0 ${Math.max(20,glow/2)}px ${W.color}33`;

    // NOVO: Halo Dourado (Golden Mode)
    if(haloIntensity > 0){
      const cxm=cv.width/2, cym=cv.height/2; 
      const maxR=Math.hypot(cxm,cym);
      const freq = 2.0; // frequ√™ncia do pulso
      const s = (Math.sin(Date.now()/1000 * Math.PI*2*freq)+1)/2;
      const alpha = haloIntensity * 0.35 * s;
      const r=maxR*(0.7 + 0.15*s);
      
      if(isFiniteNum(cxm) && isFiniteNum(cym) && isFiniteNum(r)){
        const grd=ctx.createRadialGradient(cxm,cym, Math.max(0.1, r*0.2), cxm,cym, Math.max(0.2, r));
        grd.addColorStop(0, `rgba(255,215,0, ${alpha})`);
        grd.addColorStop(0.5, `rgba(255,140,0, ${alpha*0.5})`);
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.globalCompositeOperation='screen';
        ctx.fillStyle=grd; ctx.fillRect(0,0,cv.width,cv.height);
        ctx.globalCompositeOperation='source-over';
      }
    }

    // Overlay Golden antigo (mantido para compatibilidade)
    if(invincible){
      const tLeft = Math.max(0, invEnd - Date.now());
      const k = 1 - tLeft / GOLDEN_MS;
      const freq = 1.5 + 2.0*k;
      const amp  = 0.25 + 0.35*(1-k);
      const s = (Math.sin(Date.now()/1000 * Math.PI*2*freq)+1)/2;
      const alpha = Math.min(0.25, amp*s*0.5); // reduzido para n√£o sobrepor halo
      const cxm=cv.width/2, cym=cv.height/2; const maxR=Math.hypot(cxm,cym);
      const r=maxR*(0.85+0.10*s);
      if(isFiniteNum(cxm) && isFiniteNum(cym) && isFiniteNum(r)){
        const grd=ctx.createRadialGradient(cxm,cym, Math.max(0.1, r*0.3), cxm,cym, Math.max(0.2, r));
        grd.addColorStop(0, `rgba(255,215,0, ${alpha})`);
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.globalCompositeOperation='screen';
        ctx.fillStyle=grd; ctx.fillRect(0,0,cv.width,cv.height);
        ctx.globalCompositeOperation='source-over';
      }
    }

    // Transi√ß√£o de mundos
    if(transitioning){
      const t = (now - transitionStart);
      const a = Math.min(1, t/200);
      if(t<150){
        ctx.fillStyle=`rgba(255,255,255, ${1 - t/150})`;
        ctx.fillRect(0,0,cv.width,cv.height);
      }
      ctx.save();
      ctx.fillStyle = `rgba(255,255,255, ${a})`;
      ctx.font='bold 28px ui-monospace, SFMono-Regular, Menlo, monospace';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.shadowColor=W.color; ctx.shadowBlur=18;
      ctx.fillText(transitionText, cv.width/2, cv.height/2);
      ctx.restore();
    }
  }

  // ===========================
  // DESENHO PRIMITIVOS
  // ===========================
  function drawCell(x,y,r){
    const px=x*CELL, py=y*CELL;
    ctx.beginPath();
    ctx.moveTo(px+r,py);
    ctx.arcTo(px+CELL,py,px+CELL,py+CELL,r);
    ctx.arcTo(px+CELL,py+CELL,px,py+CELL,r);
    ctx.arcTo(px,py+CELL,px,py,r);
    ctx.arcTo(px,py,px+CELL,py,r);
    ctx.closePath();
    ctx.fill();
  }

  function safeDrawOrb(x,y,color){
    const px = x*CELL + CELL/2;
    const py = y*CELL + CELL/2;
    if(!isFiniteNum(px) || !isFiniteNum(py)) return false;

    try{
      const r0=2, r1=10;
      const g = ctx.createRadialGradient(px,py, r0, px,py, r1);
      g.addColorStop(0,'#fff');
      g.addColorStop(.3,color);
      g.addColorStop(1,'#0000');
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(px,py,10,0,Math.PI*2); ctx.fill();
      return true;
    }catch(_){
      ctx.fillStyle=color; ctx.beginPath(); ctx.arc(px,py,8,0,Math.PI*2); ctx.fill();
      return false;
    }
  }

  function hexToRgba(hex, a){
    if(/^#([0-9a-f]{3}){1,2}$/i.test(hex)){
      let c=hex.slice(1); if(c.length===3) c=c.split('').map(x=>x+x).join('');
      const n=parseInt(c,16); const r=(n>>16)&255, g=(n>>8)&255, b=n&255;
      return `rgba(${r},${g},${b},${a})`;
    }
    return hex;
  }

  function getPrimaryColor(){
    const W=WORLDS[worldIndex];
    return (W.palette[0]==='rainbow') ? `hsl(${(Date.now()/100)%360},100%,60%)` : W.palette[0];
  }

  // ===========================
  // PART√çCULAS
  // ===========================
  class Particle{
    constructor(x,y,color){
      this.x=x*CELL+CELL/2; this.y=y*CELL+CELL/2;
      this.vx=(Math.random()*16-8); this.vy=(Math.random()*-10-2);
      this.life=1; this.color=color;
    }
    step(){ this.x+=this.vx; this.y+=this.vy; this.vy+=0.3; this.life-=0.03; }
    draw(){ ctx.globalAlpha=Math.max(0,this.life); ctx.fillStyle=this.color; ctx.fillRect(this.x,this.y,3,3); ctx.globalAlpha=1; }
  }
  function spawnParticles(x,y,count,color){
    for(let i=0;i<count;i++){ if(particles.length<MAX_PARTICLES) particles.push(new Particle(x,y,color)); }
  }
  function updateParticles(){
    for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.step(); p.draw(); if(p.life<=0) particles.splice(i,1); }
  }

  // ===========================
  // CONTROLES
  // ===========================
  window.addEventListener('keydown',e=>{
    if(e.code==='Space'){ if(!loopRunning) setupAudio(); if(!logicTimer) startGame(); }
    const dirs={w:{x:0,y:-1},a:{x:-1,y:0},s:{x:0,y:1},d:{x:1,y:0},ArrowUp:{x:0,y:-1},ArrowDown:{x:0,y:1},ArrowLeft:{x:-1,y:0},ArrowRight:{x:1,y:0}};
    if(dirs[e.key]) nextDir = dirs[e.key];
  });

  // ===========================
  // TESTES
  // ===========================
  (function runTests(){
    const results=[];
    function t(name, fn){
      try{ fn(); results.push({name, ok:true}); }
      catch(err){ console.error('TEST FAIL:', name, err); results.push({name, ok:false, err}); }
    }

    t('drawOrb NaN safety', ()=>{
      const ok = safeDrawOrb(NaN, NaN, '#0ff');
      if(ok!==false) throw new Error('should return false for invalid coords');
    });

    t('drawOrb valid(0,0)', ()=>{
      const ok = safeDrawOrb(0, 0, '#0ff');
      if(ok!==true) throw new Error('expected true for valid coords');
    });

    t('placeApple validity', ()=>{
      placeApple();
      if(!apple || !validCell(apple.x, apple.y)) throw new Error('apple invalid');
    });

    t('generatePowerUps validity', ()=>{
      generatePowerUps();
      for(const p of powerUps){ if(!validCell(p.x,p.y)) throw new Error('powerUp invalid'); }
    });

    t('overlay radial finite', ()=>{
      const cxm=cv.width/2, cym=cv.height/2; const maxR=Math.hypot(cxm,cym);
      const r=maxR*0.9; if(!isFiniteNum(cxm) || !isFiniteNum(cym) || !isFiniteNum(r)) throw new Error('non-finite overlay params');
    });

    const pass = results.every(r=>r.ok);
    if(pass){ testBadge.style.display='inline-block'; testBadge.textContent='Tests: PASS ('+results.length+')'; }
    else{ testBadge.style.display='inline-block'; testBadge.style.borderColor='#ff7b7b'; testBadge.textContent='Tests: FAIL ('+results.filter(r=>!r.ok).length+'/'+results.length+')'; }
  })();

  // Kickstart render loop
  requestAnimationFrame(function loop(){ try{ draw(); } catch(e){ console.error(e); } requestAnimationFrame(loop); });
})();
</script>
</body>
</html>