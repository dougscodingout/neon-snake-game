<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="utf-8" />
<title>Neon Snake — Codex Final (Golden Pulse + Worlds)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#000;font-family:system-ui,Segoe UI,Roboto,Ubuntu,sans-serif;color:#e8ffff;overflow:hidden;}
  .wrap{display:grid;place-items:center;height:100%;}
  .hud{display:flex;gap:12px;margin-bottom:12px;justify-content:center;align-items:center;flex-wrap:wrap}
  .badge{background:rgba(0,0,0,.4);border:1px solid #0ff6;border-radius:12px;padding:8px 14px;color:#cff;box-shadow:0 0 12px #0ff4,inset 0 0 6px #00fffa33;text-shadow:0 0 8px #0ff8}
  .world{border-color:#ff7bf5}
  .tests{border-color:#7fff7f}
  canvas{background:radial-gradient(circle at 40% 40%,#050015,#000);border-radius:22px;box-shadow:0 0 30px #0ff6,inset 0 0 40px #00ffee22;transition:box-shadow .25s ease, filter .3s ease;}
  .note{margin-top:8px;text-align:center;font-size:14px;opacity:.85;color:#f8f}
</style>
</head>
<body>
  <div class="wrap">
    <div>
      <div class="hud">
        <div class="badge">Score: <span id="score">0</span></div>
        <div class="badge">Best: <span id="best">0</span></div>
        <div class="badge world">World: <span id="worldLabel">1 • Cyberpunk Dusk</span></div>
        <div class="badge" id="msg">Pressione <b>Espaço</b> para iniciar</div>
        <div class="badge tests" id="testBadge" style="display:none">Tests: running…</div>
      </div>
      <canvas id="cv" width="720" height="720"></canvas>
      <div class="note">Combo • Power-ups escalonados • Golden Mode (warp+intangível) • Áudio/Reatividade • Transições de mundos</div>
    </div>
  </div>

<script>
(()=>{
  // ===========================
  // CONFIG BÁSICA
  // ===========================
  const CELL=24, COLS=30, ROWS=30; // 720x720 grid
  const cv=document.getElementById('cv');
  const ctx=cv.getContext('2d');
  const scoreEl=document.getElementById('score');
  const bestEl=document.getElementById('best');
  const msgEl=document.getElementById('msg');
  const worldEl=document.getElementById('worldLabel');
  const testBadge=document.getElementById('testBadge');

  // ===========================
  // ESTADO DE JOGO
  // ===========================
  let snake=[], dir={x:1,y:0}, nextDir={x:1,y:0};
  let apple=null, score=0, best=+localStorage.neonSnakeBest||0; // apple começa null (evita NaN)
  let tick=100;            // lógica (ms)
  let logicTimer=null;     // setInterval
  let restarting=false;

  // Combo
  let combo=0, lastEat=0;  // janela de 3s

  // Power-ups
  let powerUps=[];         // só orbes douradas p/ Golden por enquanto

  // Golden Mode 2.0
  const GOLDEN_MS=5000;    // duração total desejada
  let invincible=false, invEnd=0, slowMotion=false;

  // Partículas
  const particles=[];
  const MAX_PARTICLES=100;

  // Mundo / Progressão audiovisual
  const WORLDS=[
    { name:'Cyberpunk Dusk',   bg:'#0a0022', color:'#0ff', bpm:90,  bass:55,  palette:['#0ff','#f0f','#ff0'],  chime:false, sweep:false },
    { name:'Synthwave Sunset', bg:'#220a0a', color:'#ff1493', bpm:100, bass:65, palette:['#ff1493','#ff8800','#ffff00'], chime:false, sweep:false },
    { name:'Neon Forest',      bg:'#0a2200', color:'#0f0', bpm:110, bass:73, palette:['#0f0','#0ff','#88ffaa'], chime:false, sweep:false },
    { name:'Electric Storm',   bg:'#000a22', color:'#0af', bpm:120, bass:82, palette:['#0af','#80f','#fff'],    chime:true,  sweep:false },
    { name:'Rainbow Chaos',    bg:'#2a0a2a', color:'#0ff', bpm:130, bass:92, palette:['rainbow','#fff','#0ff'], chime:true,  sweep:true  }
  ];
  let worldIndex=0; // 0..4

  // Transição de mundos (cinemática)
  let transitioning=false;    // pausa gameplay
  let transitionText='';
  let transitionStart=0;      // ms perf counter
  const TRANSITION_MS=2000;

  // Grid/Glow/Shake reativos
  let lastBeatNow=performance.now();
  let shake=0, shakeT=0, shakeRot=0;

  // ===========================
  // ÁUDIO (Web Audio API)
  // ===========================
  let audioCtx=null, baseGain=null;
  let delayNode=null, feedbackGain=null, filterNode=null; // Golden FX
  let bassOsc=null, bassGain=null, lfo=null, lfoGain=null;
  // camadas adicionais
  let padGains=[], padOscs=[];         // world2+
  let arpInterval=null;                // world3+
  let chimeInterval=null;              // world4+
  let sweepInterval=null;              // world5+
  let loopRunning=false, tempo=90;

  function setupAudio(){
    if(loopRunning) return;
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();

    baseGain = audioCtx.createGain();
    baseGain.gain.value = 0.10;

    // Golden FX chain
    delayNode = audioCtx.createDelay(); delayNode.delayTime.value=0.25;
    feedbackGain = audioCtx.createGain(); feedbackGain.gain.value=0.25;
    filterNode = audioCtx.createBiquadFilter(); filterNode.type='lowpass'; filterNode.frequency.value=6000;

    baseGain.connect(audioCtx.destination); // dry
    baseGain.connect(delayNode);            // send→delay
    delayNode.connect(feedbackGain); feedbackGain.connect(delayNode); // feedback loop
    delayNode.connect(filterNode); filterNode.connect(audioCtx.destination); // wet

    // Bass + LFO
    bassOsc = audioCtx.createOscillator(); bassOsc.type='sawtooth';
    bassGain = audioCtx.createGain(); bassGain.gain.value=0.10;
    bassOsc.connect(bassGain).connect(baseGain);
    lfo = audioCtx.createOscillator(); lfoGain = audioCtx.createGain(); lfo.frequency.value=2; lfoGain.gain.value=25;
    lfo.connect(lfoGain).connect(bassOsc.frequency);

    // iniciar
    bassOsc.start(); lfo.start();
    loopRunning=true;

    applyWorld(true);
    scheduleBeat();
    startArpIfNeeded();
    startChimesIfNeeded();
    startSweepIfNeeded();
  }

  function beep(freq,durMs,type='sine',vol=0.12){
    if(!audioCtx) return;
    const osc=audioCtx.createOscillator(); const g=audioCtx.createGain();
    osc.type=type; osc.frequency.value=freq; g.gain.value=vol;
    osc.connect(g).connect(baseGain);
    const now=audioCtx.currentTime; osc.start();
    g.gain.exponentialRampToValueAtTime(0.0001, now + durMs/1000);
    osc.stop(now + durMs/1000);
  }

  function scheduleBeat(){
    if(!loopRunning) return;
    const beat = 60/tempo;                   // s por batida
    const nowT = audioCtx.currentTime;

    // Kick simples
    const kick = audioCtx.createOscillator(); kick.type='sine';
    const kg = audioCtx.createGain();
    kick.frequency.setValueAtTime(150, nowT);
    kick.frequency.exponentialRampToValueAtTime(40, nowT+0.2);
    kg.gain.setValueAtTime(0.4, nowT);
    kg.gain.exponentialRampToValueAtTime(0.001, nowT+0.30);
    kick.connect(kg).connect(baseGain);
    kick.start(); kick.stop(nowT+0.30);

    // Visual reativo
    lastBeatNow = performance.now();

    // Shake mais forte em Golden
    if(invincible){
      triggerShake(8, 500, 0.02);
    } else {
      triggerShake(2, 100, 0);
    }

    setTimeout(scheduleBeat, beat*1000);
  }

  function applyWorld(first=false){
    const W = WORLDS[worldIndex];
    // fundo
    document.body.style.background = `radial-gradient(circle at 50% 20%, ${W.bg}, #000)`;
    // borda do canvas (glow acompanha cor)
    cv.style.boxShadow = `0 0 40px ${W.color}99, inset 0 0 50px ${W.color}33`;

    // áudio
    if(audioCtx && bassOsc){
      bassOsc.frequency.linearRampToValueAtTime(W.bass, audioCtx.currentTime+1.0);
      tempo = W.bpm;
    }

    // Pad (world2+)
    stopPads();
    if(worldIndex>=1) startPads(W);

    // Arp (world3+)
    stopArp();
    if(worldIndex>=2) startArpIfNeeded();

    // Chimes (world4+)
    stopChimes();
    if(W.chime) startChimesIfNeeded();

    // Sweep (world5)
    stopSweep();
    if(W.sweep) startSweepIfNeeded();

    // HUD label
    worldEl.textContent = `${worldIndex+1} • ${W.name}`;

    if(!first){
      // micro flash de transição de mood
      cv.animate([{filter:'brightness(2) saturate(1.6)'},{filter:'brightness(1) saturate(1)'}],{duration:600});
    }
  }

  // ======= CAMADAS DE ÁUDIO AVANÇADAS =======
  function startPads(W){
    padOscs=[]; padGains=[];
    const freqs = [W.bass*2, W.bass*3, W.bass*4];
    freqs.forEach((f,i)=>{
      const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.value=f;
      const g=audioCtx.createGain(); g.gain.value=0.0; // fade in
      o.connect(g).connect(baseGain); o.start();
      g.gain.linearRampToValueAtTime(0.03, audioCtx.currentTime+1);
      padOscs.push(o); padGains.push(g);
    });
  }
  function stopPads(){ padOscs.forEach(o=>{try{o.stop()}catch{}}); padOscs=[]; padGains=[]; }

  function startArpIfNeeded(){
    if(arpInterval) return;
    if(!audioCtx) return;
    arpInterval = setInterval(()=>{
      const W=WORLDS[worldIndex]; if(worldIndex<2) return; // world3+
      const seq=[1,1.25,1.5,2];
      const ratio = seq[Math.floor(Math.random()*seq.length)];
      const o=audioCtx.createOscillator(); o.type='triangle'; o.frequency.value=W.bass*ratio*2;
      const g=audioCtx.createGain(); g.gain.value=0.05;
      o.connect(g).connect(baseGain);
      const t=audioCtx.currentTime; o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.3); o.stop(t+0.3);
    }, (60/Math.max(tempo,1))*500); // colcheias
  }
  function stopArp(){ if(arpInterval){ clearInterval(arpInterval); arpInterval=null; } }

  function startChimesIfNeeded(){
    if(chimeInterval) return;
    chimeInterval = setInterval(()=>{
      if(!audioCtx || !WORLDS[worldIndex].chime) return;
      const notes=[261.63,293.66,329.63,392.00,440.00];
      const n=notes[Math.floor(Math.random()*notes.length)];
      const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.value=n;
      const g=audioCtx.createGain(); g.gain.value=0.08;
      o.connect(g).connect(baseGain);
      const t=audioCtx.currentTime; o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, t+1.5); o.stop(t+1.5);
    }, (60/Math.max(tempo,1))*2000); // a cada 2 batidas
  }
  function stopChimes(){ if(chimeInterval){ clearInterval(chimeInterval); chimeInterval=null; } }

  function startSweepIfNeeded(){
    if(sweepInterval) return;
    sweepInterval = setInterval(()=>{
      if(!audioCtx || !WORLDS[worldIndex].sweep) return;
      const noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate*0.2, audioCtx.sampleRate);
      const data=noiseBuf.getChannelData(0);
      for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1;
      const src=audioCtx.createBufferSource(); src.buffer=noiseBuf;
      const bp=audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=200;
      const g=audioCtx.createGain(); g.gain.value=0.06;
      src.connect(bp).connect(g).connect(baseGain);
      const t=audioCtx.currentTime; src.start(); src.stop(t+0.4);
      bp.frequency.linearRampToValueAtTime(2000, t+0.4);
    }, (60/Math.max(tempo,1))*4000); // sweep em 4 batidas
  }
  function stopSweep(){ if(sweepInterval){ clearInterval(sweepInterval); sweepInterval=null; } }

  // GOLDEN FX
  function enterGolden(){
    invincible=true; slowMotion=true; invEnd = Date.now() + GOLDEN_MS;
    if(audioCtx){
      baseGain.gain.linearRampToValueAtTime(0.07, audioCtx.currentTime+0.4);
      filterNode.frequency.linearRampToValueAtTime(1500, audioCtx.currentTime+0.4);
      feedbackGain.gain.linearRampToValueAtTime(0.6, audioCtx.currentTime+0.4);
    }
  }
  function exitGolden(){
    invincible=false; slowMotion=false;
    if(audioCtx){
      baseGain.gain.linearRampToValueAtTime(0.10, audioCtx.currentTime+0.4);
      filterNode.frequency.linearRampToValueAtTime(6000, audioCtx.currentTime+0.4);
      feedbackGain.gain.linearRampToValueAtTime(0.25, audioCtx.currentTime+0.4);
    }
  }

  // ===========================
  // UTIL
  // ===========================
  const rnd=n=>Math.floor(Math.random()*n);
  const same=(a,b)=>a&&b&&a.x===b.x&&a.y===b.y;
  const isInt=n=>Number.isInteger(n);
  const isFiniteNum=n=>Number.isFinite(n);
  const validCell=(x,y)=>isInt(x)&&isInt(y)&&x>=0&&x<COLS&&y>=0&&y<ROWS;

  // ===========================
  // INICIALIZA / REINICIA JOGO
  // ===========================
  function startGame(){
    clearInterval(logicTimer);
    const cx=Math.floor(COLS/2), cy=Math.floor(ROWS/2);
    snake=[{x:cx,y:cy},{x:cx-1,y:cy},{x:cx-2,y:cy}];
    dir=nextDir={x:1,y:0};
    score=0; combo=0; particles.length=0;
    powerUps=[]; generatePowerUps();
    placeApple();
    transitioning=false; transitionText='';
    msgEl.textContent='Jogando…';
    scoreEl.textContent=score; bestEl.textContent=best;
    logicTimer=setInterval(stepLogic, tick);
  }

  function placeApple(){
    let tries=0;
    do{ apple={x:rnd(COLS), y:rnd(ROWS)}; tries++; if(tries>100) break; }
    while(snake.some(p=>same(p,apple)) || powerUps.some(p=>same(p,apple)));
    if(!validCell(apple.x, apple.y)) apple={x:0,y:0}; // fallback seguro
  }

  function powerupCountForLevel(){
    // 1–2:5 / 3–5:4 / 6–10:3 / 11–19:2 / 20+:1 — aproximado por score
    const sc = score;
    if(sc<20) return 5;
    if(sc<40) return 4;
    if(sc<80) return 3;
    if(sc<200) return 2;
    return 1;
  }

  function generatePowerUps(){
    powerUps=[];
    const count = powerupCountForLevel();
    for(let i=0;i<count;i++){
      let p; let guard=0;
      do{ p={x:rnd(COLS), y:rnd(ROWS)}; guard++; if(guard>200) break; }
      while(snake.some(s=>same(s,p)) || (apple && same(p,apple)));
      if(validCell(p.x,p.y)) powerUps.push(p);
    }
  }

  // ===========================
  // LÓGICA DO JOGO (INTERVAL)
  // ===========================
  function stepLogic(){
    if(transitioning) return; // pausa durante transição cinematográfica

    // Direção
    if(nextDir) dir = nextDir;

    // Próxima cabeça
    let head={x:snake[0].x+dir.x, y:snake[0].y+dir.y};

    // Paredes
    if(invincible){ // wrap-around
      if(head.x<0) head.x=COLS-1; if(head.x>=COLS) head.x=0;
      if(head.y<0) head.y=ROWS-1; if(head.y>=ROWS) head.y=0;
    } else {
      if(head.x<0||head.x>=COLS||head.y<0||head.y>=ROWS){ crash(); return; }
    }

    // Auto-colisão (desligado em Golden)
    if(!invincible && snake.some(p=>same(p,head))){ crash(); return; }

    snake.unshift(head);

    // Comer maçã
    if(apple && same(head,apple)){
      const now=Date.now();
      combo = (now-lastEat<3000) ? combo+1 : 1; lastEat=now;
      const mult = 1 + (combo-1)*0.5;
      score += Math.round(1*mult);
      scoreEl.textContent=score;
      beep(600+combo*50, 120, 'square', 0.20);
      spawnParticles(head.x, head.y, 10, getPrimaryColor());

      // thresholds de mundo por score: 0,20,40,60,80+
      maybeWorldTransition();

      placeApple();
    }
    // Pegar power-up
    else if(powerUps.some(p=>same(p,head))){
      powerUps = powerUps.filter(p=>!same(p,head));
      enterGolden();
      beep(1000, 200, 'triangle', 0.30);
      cv.animate([{filter:'brightness(2) saturate(2)'},{filter:'brightness(1) saturate(1)'}],{duration:800});
    }
    else {
      snake.pop();
    }

    // Fim do Golden
    if(invincible && Date.now()>invEnd){ exitGolden(); }
  }

  function crash(){
    if(invincible || restarting) return;
    restarting=true; cv.style.filter='brightness(2)';
    beep(120, 400, 'sawtooth', 0.25);
    best=Math.max(best,score); bestEl.textContent=best; localStorage.neonSnakeBest=best;
    clearInterval(logicTimer);
    setTimeout(()=>{ cv.style.filter='brightness(1)'; restarting=false; startGame(); }, 800);
  }

  function maybeWorldTransition(){
    const prevWorld = worldIndex;
    const s=score;
    if(s>=80) worldIndex=4; else if(s>=60) worldIndex=3; else if(s>=40) worldIndex=2; else if(s>=20) worldIndex=1; else worldIndex=0;
    if(worldIndex!==prevWorld){
      // pausa e transição
      transitioning=true; transitionStart=performance.now();
      transitionText = `ENTERING ${WORLDS[worldIndex].name.toUpperCase()}`;
      applyWorld(); generatePowerUps();
      setTimeout(()=>{ transitioning=false; }, TRANSITION_MS);
    }
  }

  // ===========================
  // RENDER (RAF 60FPS)
  // ===========================
  function animate(){
    requestAnimationFrame(animate);
    try{ draw(); }catch(err){ console.error('[draw] error', err); }
  }

  function triggerShake(px, durationMs, rot){
    shake = Math.max(shake, px);
    shakeT = performance.now() + durationMs;
    shakeRot = rot||0;
  }

  function draw(){
    const W = WORLDS[worldIndex];

    // canvas transform (shake)
    const now=performance.now();
    const activeShake = Math.max(0, shakeT - now);
    let offX=0, offY=0, rot=0;
    if(activeShake>0){
      const k = activeShake/500; // decai
      offX = (Math.random()*2-1) * shake * k;
      offY = (Math.random()*2-1) * shake * k;
      rot = (Math.random()*2-1) * (shakeRot||0) * k;
    }

    // grid pulse opacity baseado no beat (decay suave)
    const sinceBeat = now - lastBeatNow; // ms
    const beatPhase = Math.max(0, 1 - sinceBeat/200);
    const gridAlpha = 0.06 + beatPhase * 0.14; // 0.06→0.20

    // limpar
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,cv.width,cv.height);

    // aplicar shake/rotação
    ctx.translate(offX, offY);
    if(rot) ctx.rotate(rot);

    // fundo base
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,cv.width,cv.height);

    // grade (com possível leve distorção em Golden)
    ctx.strokeStyle = hexToRgba(W.color, (invincible? (gridAlpha*1.6) : gridAlpha));
    ctx.beginPath();
    for(let i=1;i<COLS;i++){
      const x=i*CELL + (invincible? Math.sin(now/100 + i)*3 : 0);
      ctx.moveTo(x+.5, 0); ctx.lineTo(x+.5, cv.height);
    }
    for(let j=1;j<ROWS;j++){
      const y=j*CELL + (invincible? Math.sin(now/120 + j)*3 : 0);
      ctx.moveTo(0, y+.5); ctx.lineTo(cv.width, y+.5);
    }
    ctx.stroke();

    // maçã (só se válida)
    if(apple && validCell(apple.x, apple.y)) safeDrawOrb(apple.x, apple.y, W.color);

    // power-ups dourados (apenas válidos)
    for(const p of powerUps){ if(validCell(p.x,p.y)) safeDrawOrb(p.x,p.y,'#ff0'); }

    // partículas
    updateParticles();

    // cobra
    snake.forEach((p,i)=>{
      const hueBase = (W.palette[0]==='rainbow') ? ((now/100 + i*6)%360) : null;
      const fill = invincible
        ? 'hsl(50,100%,65%)'
        : (hueBase!=null ? `hsl(${hueBase},100%,60%)` : W.palette[0]);
      ctx.fillStyle = fill;
      ctx.shadowColor = invincible? '#ffd700' : W.color;
      ctx.shadowBlur = invincible? 20 : 8;
      drawCell(p.x, p.y, 5);
      ctx.shadowBlur=0;
    });

    // GLOW geral do canvas (respiração no beat)
    const glow = 30 + (beatPhase*18) + score/8;
    cv.style.boxShadow = `0 0 ${glow}px ${W.color}AA, inset 0 0 ${Math.max(20,glow/2)}px ${W.color}33`;

    // Overlay Golden: pulso radial com countdown implícito
    if(invincible){
      const tLeft = Math.max(0, invEnd - Date.now());
      const k = 1 - tLeft / GOLDEN_MS; // 0→1
      const freq = 1.5 + 2.0*k;        // acelera
      const amp  = 0.25 + 0.35*(1-k);  // decai
      const s = (Math.sin(Date.now()/1000 * Math.PI*2*freq)+1)/2;
      const alpha = Math.min(0.45, amp*s);
      const cxm=cv.width/2, cym=cv.height/2; const maxR=Math.hypot(cxm,cym);
      const r=maxR*(0.85+0.10*s);
      if(isFiniteNum(cxm) && isFiniteNum(cym) && isFiniteNum(r)){
        const grd=ctx.createRadialGradient(cxm,cym, Math.max(0.1, r*0.3), cxm,cym, Math.max(0.2, r));
        grd.addColorStop(0, `rgba(255,215,0, ${alpha})`);
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.globalCompositeOperation='screen';
        ctx.fillStyle=grd; ctx.fillRect(0,0,cv.width,cv.height);
        ctx.globalCompositeOperation='source-over';
      }
    }

    // Transição de mundos (cinemática + texto)
    if(transitioning){
      const t = (now - transitionStart);
      const a = Math.min(1, t/200); // flash-in 200ms
      if(t<150){
        ctx.fillStyle=`rgba(255,255,255, ${1 - t/150})`;
        ctx.fillRect(0,0,cv.width,cv.height);
      }
      ctx.save();
      ctx.fillStyle = `rgba(255,255,255, ${a})`;
      ctx.font='bold 28px ui-monospace, SFMono-Regular, Menlo, monospace';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.shadowColor=W.color; ctx.shadowBlur=18;
      ctx.fillText(transitionText, cv.width/2, cv.height/2);
      ctx.restore();
    }
  }

  // ===========================
  // DESENHO PRIMITIVOS
  // ===========================
  function drawCell(x,y,r){
    const px=x*CELL, py=y*CELL;
    ctx.beginPath();
    ctx.moveTo(px+r,py);
    ctx.arcTo(px+CELL,py,px+CELL,py+CELL,r);
    ctx.arcTo(px+CELL,py+CELL,px,py+CELL,r);
    ctx.arcTo(px,py+CELL,px,py,r);
    ctx.arcTo(px,py,px+CELL,py,r);
    ctx.closePath();
    ctx.fill();
  }

  function safeDrawOrb(x,y,color){
    // converte coordenadas de célula → pixels
    const px = x*CELL + CELL/2;
    const py = y*CELL + CELL/2;
    if(!isFiniteNum(px) || !isFiniteNum(py)) return false; // evita NaN/Inf

    // fallback: se gradient falhar, desenha um círculo sólido
    try{
      const r0=2, r1=10;
      const g = ctx.createRadialGradient(px,py, r0, px,py, r1);
      g.addColorStop(0,'#fff');
      g.addColorStop(.3,color);
      g.addColorStop(1,'#0000');
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(px,py,10,0,Math.PI*2); ctx.fill();
      return true;
    }catch(_){
      ctx.fillStyle=color; ctx.beginPath(); ctx.arc(px,py,8,0,Math.PI*2); ctx.fill();
      return false;
    }
  }

  function hexToRgba(hex, a){
    if(/^#([0-9a-f]{3}){1,2}$/i.test(hex)){
      let c=hex.slice(1); if(c.length===3) c=c.split('').map(x=>x+x).join('');
      const n=parseInt(c,16); const r=(n>>16)&255, g=(n>>8)&255, b=n&255;
      return `rgba(${r},${g},${b},${a})`;
    }
    return hex; // fallback hsl/css
  }

  function getPrimaryColor(){
    const W=WORLDS[worldIndex];
    return (W.palette[0]==='rainbow') ? `hsl(${(Date.now()/100)%360},100%,60%)` : W.palette[0];
  }

  // ===========================
  // PARTÍCULAS
  // ===========================
  class Particle{
    constructor(x,y,color){
      this.x=x*CELL+CELL/2; this.y=y*CELL+CELL/2;
      this.vx=(Math.random()*16-8); this.vy=(Math.random()*-10-2);
      this.life=1; this.color=color;
    }
    step(){ this.x+=this.vx; this.y+=this.vy; this.vy+=0.3; this.life-=0.03; }
    draw(){ ctx.globalAlpha=Math.max(0,this.life); ctx.fillStyle=this.color; ctx.fillRect(this.x,this.y,3,3); ctx.globalAlpha=1; }
  }
  function spawnParticles(x,y,count,color){
    for(let i=0;i<count;i++){ if(particles.length<MAX_PARTICLES) particles.push(new Particle(x,y,color)); }
  }
  function updateParticles(){
    for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.step(); p.draw(); if(p.life<=0) particles.splice(i,1); }
  }

  // ===========================
  // CONTROLES
  // ===========================
  window.addEventListener('keydown',e=>{
    if(e.code==='Space'){ if(!loopRunning) setupAudio(); if(!logicTimer) startGame(); }
    const dirs={w:{x:0,y:-1},a:{x:-1,y:0},s:{x:0,y:1},d:{x:1,y:0},ArrowUp:{x:0,y:-1},ArrowDown:{x:0,y:1},ArrowLeft:{x:-1,y:0},ArrowRight:{x:1,y:0}};
    if(dirs[e.key]) nextDir = dirs[e.key];
  });

  // ===========================
  // TESTES (sanidade de gradientes/coords)
  // ===========================
  (function runTests(){
    const results=[];
    function t(name, fn){
      try{ fn(); results.push({name, ok:true}); }
      catch(err){ console.error('TEST FAIL:', name, err); results.push({name, ok:false, err}); }
    }

    // 1) drawOrb não deve quebrar com x/y inválidos
    t('drawOrb NaN safety', ()=>{
      const ok = safeDrawOrb(NaN, NaN, '#0ff');
      if(ok!==false) throw new Error('should return false for invalid coords');
    });

    // 2) drawOrb com (0,0) válidos
    t('drawOrb valid(0,0)', ()=>{
      const ok = safeDrawOrb(0, 0, '#0ff');
      if(ok!==true) throw new Error('expected true for valid coords');
    });

    // 3) placeApple gera coordenadas válidas
    t('placeApple validity', ()=>{
      placeApple();
      if(!apple || !validCell(apple.x, apple.y)) throw new Error('apple invalid');
    });

    // 4) generatePowerUps gera coordenadas válidas
    t('generatePowerUps validity', ()=>{
      generatePowerUps();
      for(const p of powerUps){ if(!validCell(p.x,p.y)) throw new Error('powerUp invalid'); }
    });

    // 5) overlay radial params são finitos (sanidade)
    t('overlay radial finite', ()=>{
      const cxm=cv.width/2, cym=cv.height/2; const maxR=Math.hypot(cxm,cym);
      const r=maxR*0.9; if(!isFiniteNum(cxm) || !isFiniteNum(cym) || !isFiniteNum(r)) throw new Error('non-finite overlay params');
    });

    const pass = results.every(r=>r.ok);
    if(pass){ testBadge.style.display='inline-block'; testBadge.textContent='Tests: PASS ('+results.length+')'; }
    else{ testBadge.style.display='inline-block'; testBadge.style.borderColor='#ff7b7b'; testBadge.textContent='Tests: FAIL ('+results.filter(r=>!r.ok).length+'/'+results.length+')'; }
  })();

  // kickstart render loop
  requestAnimationFrame(function loop(){ try{ draw(); } catch(e){ console.error(e); } requestAnimationFrame(loop); });
})();
</script>
</body>
</html>
